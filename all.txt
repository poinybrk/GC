

PROGRAM 1 : DDA line Drawing Algorithm

#include<iostream>
#include<conio.h>
#include<graphics.h>
#include<math.h>
using namespace std;
class DDAline
{
	private:
	int x1,y1,x2,y2;
	public:
	void input()
	{
		cout<<"Enter initial coordinate : ";
		cin>>x1>>y1;
		cout<<"Enter final coordinate : ";
		cin>>x2>>y2;
	}
	float findSlope()
	{
		float m;
		if(y2==y1)
		{
			if(x1>x2)
				swap(x1,x2);			
			m=0.0;
		}
			
		else if(x2==x1)
		{
			if(y1>y2)
				swap(y1,y2);
			m=-1.0;
		}
		else
			m=(float(y2-y1)/float(x2-x1));
		return m;
	}
	void drawLine()
	{
		float x=x1;
		float y=y1;
		float m=findSlope();
		cout<<x<<"  "<<y<<"  "<<m<<endl;
		if(m==0.0)
		{
			while(x<x2)
				{
					putpixel(x,y,WHITE);
					x++;	
				}
		}
		else if(m==-1.0)
		{
			while(y<y2)
			{
				putpixel(x,y,WHITE);
				y++;
			}
		}
		else
		{
			if(m<1.0)
			{
				if(x1>x2)
				{
					swap(x1,x2);
					swap(y1,y2);
				}
				x=x1;
				y=y1;
				while(x<x2)
				{
					putpixel(x,round(y),WHITE);
					x++;
					y+=m;
				}
			}
				
			else if(m>1.0)
			{
				if(y1>y2)
				{
					swap(x1,x2);
					swap(y1,y2);
				}
				x=x1;
				y=y1;
				while(y<y2)
				{
					putpixel(round(x),y,WHITE);
					y++;
					x+=(1/m);
				}
			}
			else
			{
				if(x1>x2)
				{
					swap(x1,x2);
					swap(y1,y2);
				}
				x=x1;
				y=y1;
				while(y<y2)
				{
					putpixel(round(x),y,WHITE);
					y++;
					x++;
				}													
			}						
		}
	}
};

int main()
{	
	initwindow(1024,768);	
	DDAline l;
	l.input();
	l.drawLine();
	getch();
}




****************************************************************************************************************************
PROGRAM 2 : Brezenhams line drawing algorithm

#include<iostream>
#include<conio.h>
#include<graphics.h>
using namespace std;

int main()
{
	int dx,dy,x,y,p,x1,y1,x2,y2;
	initwindow(800,800);
	cout<<"\n\nEnter the co-ordinates of first point : ";
	cin>>x1>>y1;
	cout<<"\n\nEnter the co-ordinates of second point : ";
	cin>>x2>>y2;
	
	if(abs(x1-x2)>=abs(y1-y2))
	{
		if(x1>x2)
		{
			swap(x1,x2);
			swap(y1,y2);
		}
		else if(x1==x2)
		{
			if(y1>y2) swap(y1,y2);
		}
		
		dx = x2-x1;
		dy = y2-y1;
		p = 2*dy-dx;
		
		for(x=x1,y=y1; x<=x2; x++)
		{
			putpixel(x,y,3);
			if(p<0) p = p + 2*dy;
			else
			{
				y++;
				p = p + 2*(dy-dx);
			}
		}
	}
	else
	{
		if(y1>y2)
		{
			swap(x1,x2);
			swap(y1,y2);
		}
		else if(y1==y2)
		{
			if(x1>x2) swap(x1,x2);
		}
		
		dx = x2-x1;
		dy = y2-y1;
		p = 2*dx-dy;
		
		for(x=x1,y=y1; y<=y2; y++)
		{
			putpixel(x,y,3);
			if(p<0) p = p + 2*dx;
			else
			{
				x++;
				p = p + 2*(dx-dy);
			}
		}
	}
	getch();
	return 0;
}
****************************************************************************************************************************
PROGRAM 3 : BREZENHEMS MID POINT CIRCLE ALGORITHM

#include<iostream>
#include<conio.h>
#include<graphics.h>
using namespace std;

void drawCircle(int x, int y, int xc, int yc)
{
    putpixel(xc+x, yc+y, 3);
    putpixel(xc-x, yc+y, 3);
    putpixel(xc+x, yc-y, 3);
    putpixel(xc-x, yc-y, 3);
    putpixel(xc+y, yc+x, 3);
    putpixel(xc-y, yc+x, 3);
    putpixel(xc+y, yc-x, 3);
    putpixel(xc-y, yc-x, 3);
}

int main()
{
	initwindow(800,800);
	int r, xc, yc, pk, x, y;
	cout<<"\nEnter the center co-ordinates : ";
	cin>>xc>>yc;
	cout<<"\nEnter the radius of circle : ";
	cin>>r;
	pk = 3-2*r;
	x = 0;
	y = r;
	while(x<=y)
	{
		drawCircle(x,y,xc,yc);
		x++;
		if(pk<=0) pk = pk + (4*x) + 6;
		else
		{
			y--;
			pk = pk + (4*(x-y)) + 10;
		}
	}
	getch();
	return 0;
}
**********************************************************************************************************************************
PROGRAM 4 : COHEN AND SUTHERLAND LINE DRAWING ALGORITHM



// C++ program to implement Cohen Sutherland algorithm for line clipping.
#include<iostream>
#include<conio.h>
#include<graphics.h>
using namespace std;

// Defining region codes
const int INSIDE = 0; // 0000
const int LEFT = 1;   // 0001
const int RIGHT = 2;  // 0010
const int BOTTOM = 4; // 0100
const int TOP = 8;    // 1000

// Defining x_max, y_max and x_min, y_min for clipping rectangle. 
// Since diagonal points are enough to define a rectangle.
int x_max,y_max,x_min,y_min;

// Function to compute region code for a point(x, y)
int computeCode(double x, double y)
{
    // initialized as being inside 
    int code = INSIDE;

    if (x < x_min)  code |= LEFT;         // to the left of rectangle
    else if (x > x_max)  code |= RIGHT;   // to the right of rectangle
        
    if (y < y_min)  code |= BOTTOM;       // below the rectangle
    else if (y > y_max)  code |= TOP;     // above the rectangle

    return code;
}

// Implementing Cohen-Sutherland algorithm
// Clipping a line from P1 = (x2, y2) to P2 = (x2, y2)
void cohenSutherlandClip(double x1, double y1, double x2, double y2)
{
    // Compute region codes for P1, P2
    int code1 = computeCode(x1, y1);
    int code2 = computeCode(x2, y2);

    // Initialize line as outside the rectangular window
    bool accept = false;

    while (true)
    {
        if ((code1 == 0) && (code2 == 0))
        {
            // If both endpoints lie within rectangle
            accept = true;
            break;
        }
        else if (code1 & code2)
        {
            // If both endpoints are outside rectangle, in same region
            break;
        }
        else
        {
            // Some segment of line lies within the rectangle
            int code_out;
            double x, y;

            // At least one endpoint is outside the rectangle, pick it.
            if (code1 != 0)  code_out = code1;
            else  code_out = code2;

            // Find intersection point;
            // using formulas y = y1 + slope * (x - x1),
            // x = x1 + (1 / slope) * (y - y1)
            if (code_out & TOP)
            {
                // point is above the clip rectangle
                x = x1 + (x2 - x1) * (y_max - y1) / (y2 - y1);
                y = y_max;
            }
            else if (code_out & BOTTOM)
            {
                // point is below the rectangle
                x = x1 + (x2 - x1) * (y_min - y1) / (y2 - y1);
                y = y_min;
            }
            else if (code_out & RIGHT)
            {
                // point is to the right of rectangle
                y = y1 + (y2 - y1) * (x_max - x1) / (x2 - x1);
                x = x_max;
            }
            else if (code_out & LEFT)
            {
                // point is to the left of rectangle
                y = y1 + (y2 - y1) * (x_min - x1) / (x2 - x1);
                x = x_min;
            }

            // Now intersection point x,y is found
            // We replace point outside rectangle by intersection point
            if (code_out == code1)
            {
                x1 = x;
                y1 = y;
                code1 = computeCode(x1, y1);
            }
            else
            {
                x2 = x;
                y2 = y;
                code2 = computeCode(x2, y2);
            }
        }
    }
    if (accept)
    {
    	line(x1,y1,x2,y2);
        cout<<"Line accepted from "<<x1<<", "<<y1<<" to "<<x2<<", "<<y2<<endl;
    }
    else cout << "Line rejected" << endl;
}

int main()
{
	initwindow(800,800);
	int x1,x2,y1,y2;
	cout<<"Enter diagonal points of Clipping Rectangle :-\n";
	cin>>x_min>>y_min>>x_max>>y_max;
	cout<<"\nClipping Rectangle is : ("<<x_min<<","<<y_min<<"), ("<<x_min<<","<<y_max
		<<"), ("<<x_max<<","<<y_min<<"), ("<<x_max<<","<<y_max<<")\n\n";
	
	setcolor(YELLOW);
	line(x_min,y_min,x_max,y_min);
	line(x_min,y_min,x_min,y_max);
	line(x_min,y_max,x_max,y_max);
	line(x_max,y_max,x_max,y_min);
	
	cout<<"Enter line coordinates : ";
	cin>>x1>>y1>>x2>>y2;
	setcolor(RED);
	line(x1, y1, x2, y2);
	
	
	getch();
	cleardevice();
	setcolor(YELLOW);
	line(x_min,y_min,x_max,y_min);
	line(x_min,y_min,x_min,y_max);
	line(x_min,y_max,x_max,y_max);
	line(x_max,y_max,x_max,y_min);
	
	setcolor(RED);
    cohenSutherlandClip(x1, y1, x2, y2);
	getch();
    return 0;
}


****************************************************************************************************************************
PROGRAM 5 : SUTHERLAND HODGEMAN POLYGON CLIPPING ALGORITHM

 #include<iostream>
#include<graphics.h>
#include<conio.h>
#include<dos.h>
using namespace std;

double polygon[100][2];
double clipped_polygon[100][2];
int vertices=0,output_vertices=0;
double xmin,ymin,xmax,ymax;

void display_polygon()
{
     int i=0;

     for(i=0;i<vertices-1;i++)
     line(polygon[i][0],polygon[i][1],polygon[i+1][0],polygon[i+1][1]);
     line(polygon[i][0],polygon[i][1],polygon[0][0],polygon[0][1]);
}

void left_clipping();
void right_clipping();
void bottom_clipping();
void top_clipping();

void sutherland_hodgeman()
{
     left_clipping();
     right_clipping();
     bottom_clipping();
     top_clipping();

     cleardevice();
     cout<<"\n The completely clipped polygon: ";

     setcolor(YELLOW);
     rectangle(xmin,ymin,xmax,ymax);
     delay(20);
     display_polygon();
     delay(20);
}


void left_clipping()
{
     int i=0;
     double x1,y1,x2,y2,x,y,m;

     for(i=0;i<vertices;i++)
     {
       if(i!=vertices-1)
       {
	 x1=polygon[i][0];
	 y1=polygon[i][1];
	 x2=polygon[i+1][0];
	 y2=polygon[i+1][1];
       }
       else
       {
	 x1=polygon[i][0];
	 y1=polygon[i][1];
	 x2=polygon[0][0];
	 y2=polygon[0][1];
       }

	 if(x1<xmin&&x2>=xmin)
	 {
	    m=(y2-y1)/(x2-x1);           //slope
	    x=xmin;                      //Point of intersection
	    y=y2+((xmin-x2)*m);

	    clipped_polygon[output_vertices][0]=x;
	    clipped_polygon[output_vertices][1]=y;
	    output_vertices++;

	    clipped_polygon[output_vertices][0]=x2;
	    clipped_polygon[output_vertices][1]=y2;
	    output_vertices++;
	 }
	 else
	 if(x1>=xmin&&x2>=xmin)
	 {
	    clipped_polygon[output_vertices][0]=x2;
	    clipped_polygon[output_vertices][1]=y2;
	    output_vertices++;
	 }
	 else
	 if(x1>=xmin&&x2<xmin)
	 {
	    m=(y2-y1)/(x2-x1);           //slope
	    x=xmin;                      //point of intersection
	    y=y2+((xmin-x2)*m);

	    clipped_polygon[output_vertices][0]=x;
	    clipped_polygon[output_vertices][1]=y;
	    output_vertices++;
	 }
     }

/*****************************************************************************
Copying back the partially clipped polygon to the original polygon
*****************************************************************************/

     vertices=output_vertices;

     for(i=0;i<vertices;i++)
     {
	 polygon[i][0]=clipped_polygon[i][0];
	 polygon[i][1]=clipped_polygon[i][1];
     }
     output_vertices=0;

     cleardevice();

     setcolor(BROWN);
     rectangle(xmin,ymin,xmax,ymax);
     delay(20);
     display_polygon();
     delay(20);
     getch();
}


void right_clipping()
{
     cleardevice();
     int i=0;
     double x1,y1,x2,y2,x,y,m;

     for(i=0;i<vertices;i++)
     {
       if(i!=vertices-1)
       {
	 x1=polygon[i][0];
	 y1=polygon[i][1];
	 x2=polygon[i+1][0];
	 y2=polygon[i+1][1];
       }
       else
       {
	 x1=polygon[i][0];
	 y1=polygon[i][1];
	 x2=polygon[0][0];
	 y2=polygon[0][1];
       }

	 if(x1<=xmax&&x2>xmax)
	 {
	    m=(y2-y1)/(x2-x1);           //slope
	    x=xmax;                      //Point of intersection
	    y=y2+((xmax-x2)*m);

	    clipped_polygon[output_vertices][0]=x;
	    clipped_polygon[output_vertices][1]=y;
	    output_vertices++;
	 }
	 else
	 if(x1<=xmax&&x2<=xmax)
	 {
	    clipped_polygon[output_vertices][0]=x2;
	    clipped_polygon[output_vertices][1]=y2;
	    output_vertices++;
	 }
	 else
	 if(x1>xmax&&x2<=xmax)
	 {
	    m=(y2-y1)/(x2-x1);           //slope
	    x=xmax;                      //point of intersection
	    y=y2+((xmax-x2)*m);

	    clipped_polygon[output_vertices][0]=x;
	    clipped_polygon[output_vertices][1]=y;
	    output_vertices++;

	    clipped_polygon[output_vertices][0]=x2;
	    clipped_polygon[output_vertices][1]=y2;
	    output_vertices++;
	 }
     }

/*****************************************************************************
Copying back the partially clipped polygon to the original polygon
*****************************************************************************/

     vertices=output_vertices;

     for(i=0;i<vertices;i++)
     {
	 polygon[i][0]=clipped_polygon[i][0];
	 polygon[i][1]=clipped_polygon[i][1];
     }
     output_vertices=0;

     cleardevice();

     setcolor(CYAN);
     rectangle(xmin,ymin,xmax,ymax);
     delay(20);
     display_polygon();
     delay(20);
     getch();

}


void bottom_clipping()
{
     int i=0;
     double x1,y1,x2,y2,x,y,m;

     for(i=0;i<vertices;i++)
     {

       if(i!=vertices-1)
       {
	 x1=polygon[i][0];
	 y1=polygon[i][1];
	 x2=polygon[i+1][0];
	 y2=polygon[i+1][1];
       }
       else
       {
	 x1=polygon[i][0];
	 y1=polygon[i][1];
	 x2=polygon[0][0];
	 y2=polygon[0][1];
       }

	 if(y1<ymin&&y2>=ymin)
	 {
	    m=(y2-y1)/(x2-x1);           //slope
	    y=ymin;                      //Point of intersection
	    x=x2+((ymin-y2)/m);

	    clipped_polygon[output_vertices][0]=x;
	    clipped_polygon[output_vertices][1]=y;
	    output_vertices++;

	    clipped_polygon[output_vertices][0]=x2;
	    clipped_polygon[output_vertices][1]=y2;
	    output_vertices++;
	 }
	 else
	 if(y1>=ymin&&y2>=ymin)
	 {
	    clipped_polygon[output_vertices][0]=x2;
	    clipped_polygon[output_vertices][1]=y2;
	    output_vertices++;
	 }
	 else
	 if(y1>=ymin&&y2<ymin)
	 {
	    m=(y2-y1)/(x2-x1);           //slope
	    y=ymin;                      //Point of intersection
	    x=x2+((ymin-y2)/m);

	    clipped_polygon[output_vertices][0]=x;
	    clipped_polygon[output_vertices][1]=y;
	    output_vertices++;
	 }
     }

/*****************************************************************************
Copying back the partially clipped polygon to the original polygon
*****************************************************************************/

     vertices=output_vertices;

     for(i=0;i<vertices;i++)
     {
	 polygon[i][0]=clipped_polygon[i][0];
	 polygon[i][1]=clipped_polygon[i][1];
     }
     output_vertices=0;

     cleardevice();

     setcolor(BLUE);
     rectangle(xmin,ymin,xmax,ymax);
     delay(20);
     display_polygon();
     delay(20);
     getch();

}


void top_clipping()
{
     int i=0;
     double x1,y1,x2,y2,x,y,m;

     for(i=0;i<vertices;i++)
     {
       if(i!=vertices-1)
       {
	 x1=polygon[i][0];
	 y1=polygon[i][1];
	 x2=polygon[i+1][0];
	 y2=polygon[i+1][1];
       }
       else
       {
	 x1=polygon[i][0];
	 y1=polygon[i][1];
	 x2=polygon[0][0];
	 y2=polygon[0][1];
       }

	 if(y1<=ymax&&y2>ymax)
	 {
	    m=(y2-y1)/(x2-x1);           //slope
	    y=ymax;                      //Point of intersection
	    x=x2+((ymax-y2)/m);

	    clipped_polygon[output_vertices][0]=x;
	    clipped_polygon[output_vertices][1]=y;
	    output_vertices++;
	 }
	 else
	 if(y1<=ymax&&y2<=ymax)
	 {
	    clipped_polygon[output_vertices][0]=x2;
	    clipped_polygon[output_vertices][1]=y2;
	    output_vertices++;
	 }
	 else
	 if(y1>ymax&&y2<=ymax)
	 {
	    m=(y2-y1)/(x2-x1);           //slope
	    y=ymax;                      //Point of intersection
	    x=x2+((ymax-y2)/m);

	    clipped_polygon[output_vertices][0]=x;
	    clipped_polygon[output_vertices][1]=y;
	    output_vertices++;

	    clipped_polygon[output_vertices][0]=x2;
	    clipped_polygon[output_vertices][1]=y2;
	    output_vertices++;
	 }
     }

/*****************************************************************************
Copying back the partially clipped polygon to the original polygon
*****************************************************************************/

     vertices=output_vertices;

     for(i=0;i<vertices;i++)
     {
	 polygon[i][0]=clipped_polygon[i][0];
	 polygon[i][1]=clipped_polygon[i][1];
     }
     output_vertices=0;

     cleardevice();

     setcolor(GREEN);
     rectangle(xmin,ymin,xmax,ymax);
     delay(20);
     display_polygon();
     delay(20);
     getch();
}


int main()
{
    int gd=DETECT,gm,i=0;

    cout<<"\n ****SUTHERLAND HODGMAN POLYGON CLIPPING ALGORITHM****";
    cout<<"\n Enter details of the clipping rectangle.";
    cout<<"\n Minimum X-coordinate: ";
    cin>>xmin;
    cout<<"\n Maximum X-coordinate: ";
    cin>>xmax;
    cout<<"\n Minimum Y-coordinate: ";
    cin>>ymin;
    cout<<"\n Maximum Y-coordinate: ";
    cin>>ymax;

    cout<<"\n Enter the details of the polygon to be clipped.";
    cout<<"\n Enter the number of vertices of the polygon: ";
    cin>>vertices;

    for(i=0;i<vertices;i++)
    {
	cout<<"\n Enter vertex "<<i+1<<": ";
	cout<<"\n x1: ";
	cin>>polygon[i][0];
	cout<<" y1: ";
	cin>>polygon[i][1];
    }

	 initgraph(&gd,&gm,"C:\\Turboc3\\BGI");
	 cout<<"\n The unclipped polygon: ";

	 setcolor(RED);
	 rectangle(xmin,ymin,xmax,ymax);
	 delay(20);
	 display_polygon();
	 delay(20);

	 getch();
	 sutherland_hodgeman();

	 getch();
	 closegraph();
}


****************************************************************************************************************************
PROGRAM 6 : SCANLINE POLYGON FILLING ALGORITHM


#include<iostream>
#include<conio.h>
#include<graphics.h>
using namespace std;

// Define the structure to store the edges
struct edge
{
	int x1,y1,x2,y2,flag;
};

int main()
{
	int gd=DETECT,gm,n,i,j,k;
	edge ed[10], temped;
	float dx,dy,m[10],x_int[10],inter_x[10];
	int x[10],y[10],ymax=0,ymin=480,yy,temp;
	initgraph(&gd,&gm,"");
	
	/*read the number of vertices of the polygon*/
	cout<<"Enter the no. of vertices of the polygon : ";
	cin>>n;
	/*read the vertices of the polygon and also find ymax and ymin*/
	cout<<"\nEnter the vertices :- \n";
	for(i=0;i<n;i++) 
	{
		cout<<"P"<<i+1<<" : ";
		cin>>x[i]>>y[i];
		if(y[i]>ymax)
			ymax=y[i];
		if(y[i]<ymin)
			ymin=y[i];
		ed[i].x1=x[i];
		ed[i].y1=y[i]; 
	}
	
	/*store the edge information*/
	for(i=0;i<n-1;i++) 
	{
		ed[i].x2=ed[i+1].x1;
		ed[i].y2=ed[i+1].y1;
		ed[i].flag=0;
	}
		
	ed[i].x2=ed[0].x1;
	ed[i].y2=ed[0].y1;
	ed[i].flag=0;
	/*Check for y1>y2, if not interchnge y1 and y2 */
	for(i=0;i<n;i++)
	{
		if(ed[i].y1 < ed[i].y2) 
		{
			temp=ed[i].x1;
			ed[i].x1=ed[i].x2;/////////////
			ed[i].x2=temp;
			temp=ed[i].y1;
			ed[i].y1=ed[i].y2;
			ed[i].y2=temp;
		}
	}
	
	/*Draw the polygon*/
	for(i=0;i<n;i++)
	{
		line(ed[i].x1, ed[i].y1,ed[i].x2,ed[i].y2);
	}
	
	/*sorting of edges in the order of y1,y2,x1*/
	for(i=0;i<n-1;i++)
	{
		for(j=0;j<n-1;j++) 
		{
			if(ed[j].y1<ed[j+1].y1) 
			{
				temped=ed[j];
				ed[j]=ed[j+1];
				ed[j+1]=temped;
			}
			if(ed[j].y1==ed[j+1].y1) 
			{
				if(ed[j].y2<ed[j+1].y2) 
				{
					temped=ed[j];
					ed[j]=ed[j+1];
					ed[j+1]=temped;
				}
				
				if (ed[j].y2==ed[j+1].y2)
				{
					if(ed[j].x1<ed[j+1].x1) 
					{
						temped=ed[j];
						ed[j]=ed[j+1];
						ed[j+1]=temped;
					}
				}
			}
		}
	}
	
	/*calculating 1/slope of each edge and storing top*/
	for(i=0;i<n;i++)
	{
		dx=ed[i].x2-ed[i].x1;
		dy=ed[i].y2-ed[i].y1;
		if(dy==0)
		{
			m[i]=0;
		}
		else 
		{
			m[i]=dx/dy; 
		}
		inter_x[i]=ed[i].x1;
	}
		
	/*making the Actual edges*/
	yy=ymax;
	while(yy>ymin)
	{
		for(i=0;i<n;i++) 
		{
			if(yy>ed[i].y2 && yy<=ed[i].y1) 
			{
				ed[i].flag=1; 
			}
			else
				ed[i].flag=0;
		}
		
		j=0;
		for(i=0;i<n;i++)
		{
			if(ed[i].flag==1)
			{
				if(yy==ed[i].y1)
				{
					x_int[j]==ed[i].x1;
					j++;
					if(ed[i-1].y1==yy && ed[i-1].y1<yy) 
					{
						x_int[j]=ed[i].x1;
						j++; 
					}
					if(ed[i+1].y1==yy && ed[i+1].y1<yy)
					{
						x_int[j]=ed[i].x1;
						j++; 
					}
				}
				else 
				{
					x_int[j]=inter_x[i]+(-m[i]);
					inter_x[i]=x_int[j];
					j++; 
				} 
			}
		}
	
		/*sorting the x intersaction*/
		for(i=0;i<j;i++)
		{
			for(k=0;k<j-1;k++)
			{
				if(x_int[k]>x_int[k+1])
				{
					temp=(int)x_int[k];
					x_int[k]=x_int[k+1];
					x_int[k+1]=temp;
				}
			}
		}
		
		/*extracting pairs of values to draw lilnes*/
		for(i=0;i<j;i=i+2)
		{
			line((int)x_int[i],yy,(int)x_int[i+1],yy);
		}
		yy--;
		delay(10);
	}
	getch();
	return 0;
}
****************************************************************************************************************************
PROGRAM 7 : 2D TRANSFORMATIONS


#include<iostream>
#include<graphics.h>
#include<conio.h>
#include<dos.h>
#include<math.h>
using namespace std;
#define pi 3.14285714

class transformations
{
      double vertices[3][3];             //matrix contains vertices of the triangle
      double t_matrix[3][3];             //transformation matrix
      double result[3][3];

      public:
      transformations(){};

      void get_vertices();
      void display_triangle();
      void display_triangle_result();

      void multiplication();
      void copyback();

      void rotation(double angle,double m,double n);
      void reflection(double m,double c);
      void scaling(double a,double d,double m,double n);
      void shearing(double b,double c);

};


void transformations::get_vertices()
{
     int i=0;

     for(i=0;i<3;i++)
     {
	 cout<<"\n Enter vertex "<<i+1<<": ";
	 cout<<"\n x1: ";
	 cin>>vertices[i][0];
	 result[i][0]=vertices[i][0];

	 cout<<"\n y1: ";
	 cin>>vertices[i][1];
	 result[i][1]=vertices[i][1];

	 vertices[i][2]=result[i][2]=1;
     }
}


void transformations::display_triangle()
{
     int i=0;

     for(i=0;i<2;i++)
     line(vertices[i][0],vertices[i][1],vertices[i+1][0],vertices[i+1][1]);
     line(vertices[i][0],vertices[i][1],vertices[0][0],vertices[0][1]);
}


void transformations::display_triangle_result()
{
     int i=0;

     for(i=0;i<2;i++)
     line(result[i][0],result[i][1],result[i+1][0],result[i+1][1]);
     line(result[i][0],result[i][1],result[0][0],result[0][1]);
}


void transformations::copyback()
{
     int i=0,j=0;

     for(i=0;i<3;i++)
     for(j=0;j<3;j++)
     result[i][j]=vertices[i][j];
}


void transformations::multiplication()
{
     double r[3][3];
     int i=0,j=0,k=0;

	 for(i=0;i<3;i++)
	 {
	     for(j=0;j<3;j++)
	     {
		 r[i][j]=0;
		 for(k=0;k<3;k++)
		 r[i][j]+=result[i][k]*t_matrix[k][j];
	     }
	 }

     for(i=0;i<3;i++)              //Copying back the result
     for(j=0;j<3;j++)
     result[i][j]=r[i][j];
}

//ROTATION

void transformations::rotation(double angle,double m,double n)
{
     angle=((pi/180)*angle);

     copyback();
     cleardevice();

     setcolor(RED);
     display_triangle();
     delay(20);
     getch();

     t_matrix[0][0]=1;                     //Matrix for translating the triangle to origin
     t_matrix[0][1]=0;
     t_matrix[0][2]=0;
     t_matrix[1][0]=0;
     t_matrix[1][1]=1;
     t_matrix[1][2]=0;
     t_matrix[2][0]=(m*(-1));
     t_matrix[2][1]=(n*(-1));
     t_matrix[2][2]=1;

	      multiplication();

     t_matrix[0][0]=cos(angle);             //Matrix to perform rotation about origin
     t_matrix[0][1]=sin(angle);
     t_matrix[1][0]=(sin(angle)*(-1));;
     t_matrix[1][1]=cos(angle);
     t_matrix[2][0]=0;
     t_matrix[2][1]=0;

	      multiplication();

     t_matrix[0][0]=1;                      //Matrix to translate back to original centre of rotation
     t_matrix[0][1]=0;
     t_matrix[1][0]=0;
     t_matrix[1][1]=1;
     t_matrix[2][0]=m;
     t_matrix[2][1]=n;

	      multiplication();

    setcolor(GREEN);
    display_triangle_result();
    delay(20);
    getch();
}

//REFLECTION

void transformations::reflection(double m,double c)
{
     double angle=atan(m);                //tan inverse(slope)=angle

     copyback();
     cleardevice();

     double x1=0,y1=c,x2=400,y2=(m*x2)+c;
     setcolor(YELLOW);
     line(x1,y1,x2,y2);
     delay(20);
     getch();

     setcolor(RED);
     display_triangle();
     delay(20);
     getch();

     t_matrix[0][0]=1;                     //translate (0,-c)
     t_matrix[0][1]=0;
     t_matrix[0][2]=0;
     t_matrix[1][0]=0;
     t_matrix[1][1]=1;
     t_matrix[1][2]=0;
     t_matrix[2][0]=0;
     t_matrix[2][1]=(c*(-1));
     t_matrix[2][2]=1;

	      multiplication();

     t_matrix[0][0]=cos(-1*angle);             //rotate the object about the x-axis by -angle
     t_matrix[0][1]=sin(-1*angle);
     t_matrix[1][0]=(sin(-1*angle)*(-1));;
     t_matrix[1][1]=cos(-1*angle);
     t_matrix[2][0]=0;
     t_matrix[2][1]=0;

	      multiplication();

     t_matrix[0][0]=1;                      //reflection about x-axis
     t_matrix[0][1]=0;
     t_matrix[1][0]=0;
     t_matrix[1][1]=-1;
     t_matrix[2][0]=0;
     t_matrix[2][1]=0;

	      multiplication();

     t_matrix[0][0]=cos(angle);             //rotate the object about the x-axis by -angle
     t_matrix[0][1]=sin(angle);
     t_matrix[1][0]=(sin(angle)*(-1));;
     t_matrix[1][1]=cos(angle);
     t_matrix[2][0]=0;
     t_matrix[2][1]=0;

	      multiplication();

     t_matrix[0][0]=1;                       //translating back to original line of reflection
     t_matrix[0][1]=0;
     t_matrix[1][0]=0;
     t_matrix[1][1]=1;
     t_matrix[2][0]=0;
     t_matrix[2][1]=c;

	      multiplication();

    setcolor(GREEN);
    display_triangle_result();
    delay(20);
    getch();
}


//SCALING

void transformations::scaling(double a,double d, double m, double n)
{
     copyback();
     cleardevice();

     setcolor(RED);
     display_triangle();
     delay(20);
     getch();

     t_matrix[0][0]=1;                     //Matrix for translating the triangle to origin
     t_matrix[0][1]=0;
     t_matrix[0][2]=0;
     t_matrix[1][0]=0;
     t_matrix[1][1]=1;
     t_matrix[1][2]=0;
     t_matrix[2][0]=(m*(-1));
     t_matrix[2][1]=(n*(-1));
     t_matrix[2][2]=1;

     multiplication();

     t_matrix[0][0]=a;                     //Matrix for scaling the triangle
     t_matrix[0][1]=0;
     t_matrix[0][2]=0;
     t_matrix[1][0]=0;
     t_matrix[1][1]=d;
     t_matrix[1][2]=0;
     t_matrix[2][0]=0;
     t_matrix[2][1]=0;
     t_matrix[2][2]=1;

	      multiplication();

     t_matrix[0][0]=1;                     //Matrix for translating the triangle to origin
     t_matrix[0][1]=0;
     t_matrix[0][2]=0;
     t_matrix[1][0]=0;
     t_matrix[1][1]=1;
     t_matrix[1][2]=0;
     t_matrix[2][0]=m;
     t_matrix[2][1]=n;
     t_matrix[2][2]=1;


    setcolor(GREEN);
    display_triangle_result();
    delay(20);
    getch();
}


//SHEARING

void transformations::shearing(double b,double c)
{
     copyback();
     cleardevice();

     setcolor(RED);
     display_triangle();
     delay(20);
     getch();

     t_matrix[0][0]=0;                     //Matrix for shearing the triangle
     t_matrix[0][1]=b;
     t_matrix[0][2]=0;
     t_matrix[1][0]=c;
     t_matrix[1][1]=0;
     t_matrix[1][2]=0;
     t_matrix[2][0]=0;
     t_matrix[2][1]=0;
     t_matrix[2][2]=1;

	      multiplication();

    setcolor(GREEN);
    display_triangle_result();
    delay(20);
    getch();
}


int main()
{
    int gd=DETECT,gm,choice;
    transformations t1;
    char ch1,ch2;
    double angle,m,n,slope,intercept,a,b,c,d;

    do
    {
       cout<<"\n ****TWO DIMENSIONAL TRANSFORMATIONS****\n";
       cout<<"\n Enter the details of a triangle(i.e. 2-D object): ";
       t1.get_vertices();

	  do
	  {
	      initgraph(&gd,&gm,"C:\\Turboc3\\BGI");
	      cout<<"\n ****MENU****";
	      cout<<"\n 1. Rotation.";
	      cout<<"\n 2. Reflection.";
	      cout<<"\n 3. Scaling.";
	      cout<<"\n 4. Shearing.";
              cout<<"\n Your choice goes here: ";
	      cin>>choice;

	      switch(choice)
	      {
		  case 1:cout<<"\n ----ROTATION----";
			 cout<<"\n Enter the angle of rotation: ";
			 cin>>angle;

			 cout<<"\n Enter the point about which the rotation is to be performed: ";
			 cout<<"\n X coordinate: ";
			 cin>>m;
			 cout<<"\n Y coordinate: ";
			 cin>>n;

			 t1.rotation(angle,m,n);
			 break;

		   case 2:cout<<"\n ----REFLECTION----";
			 cout<<"\n To enter the line in slope-intercept form(i.e. y=mx+c): ";
			 cout<<"\n Enter the slope(m): ";
			 cin>>slope;
			 cout<<"\n Enter the y-intercept(c): ";
			 cin>>intercept;

			 t1.reflection(slope,intercept);
			 break;

		  case 3:cout<<"\n ----SCALING----";
			 cout<<"\n Enter the point about which the rotation is to be performed: ";
			 cout<<"\n X coordinate: ";
			 cin>>m;
			 cout<<"\n Y coordinate: ";
			 cin>>n;
			 cout<<"\n Enter the factor of scaling: ";
			 cout<<"\n Along the X-axis: ";
			 cin>>a;
			 cout<<"\n Along the Y-axis: ";
			 cin>>d;

			 t1.scaling(a,d,m,n);
			 break;

		  case 4:cout<<"\n ----SHEARING----";
			 cout<<"\n Enter the factor of shearing: ";
			 cout<<"\n Along the X-axis: ";
			 cin>>c;
			 cout<<"\n Along the Y-axis: ";
			 cin>>b;

			 t1.shearing(b,c);
			 break;

		 default:cout<<"\n Wrong input!";
			 getch();
	      }

	      closegraph();

	      cout<<"\n Do you want to try another transformation? ";
	      cin>>ch2;

	  }while(ch2=='y');

       cout<<"\n Do you want to try a triangle with different dimentions? ";
       cin>>ch1;

    }while(ch1=='y');
}


****************************************************************************************************************************
PROGRAM 8 : 3D TRANSFORMATIONS

#include<iostream>
#include<math.h>
#include<conio.h>
#include<graphics.h>
using namespace std;

class matrix
{
    int nodes[10][4];
    float T[4][4];
    int size;
    public:
    matrix(int s)
    {
        size = s;
        cout << "\nThe number of nodes are : \n" << size; 
        for(int i =0;i<size;++i)
            nodes[i][3] = 1;
    }
    
    void input()
    {
        cout << endl;
        for(int i=0;i<size;++i)
        {
            cout << "Enter P" << i<<" : ";
            for(int j=0;j<3;++j)
                cin >> nodes[i][j];
        }
        cout << "\nBefore\n";
        drawMy(nodes);
        cout << endl;
    }
    
    void drawMy(int x[][4])
    {
        cout << "\nTransformation"<<endl;
        for(int i=0;i<size;++i)
        {
            line(200 + x[i%size][0],200 +  x[i%size][1], 200 + x[(i+1)%size][0],200 +  x[(i+1)%size][1]);
        }
        cout << endl;
    }
    
    void rotation()
    {
    	setcolor(RED);
        for(int i=0;i<size;++i)
        {
            for(int j=0;j<4;++j)
            {
                cout << nodes[i][j] << " ";
            }
            cout << endl;
        }
        int angle;
        cout << "Enter angle along x axis : ";
        cin >> angle;
        float r = angle*(3.14/180);
        float T[4][4];
        T[0][0] = 1;
        for (int i=1;i<=3;++i) T[0][i] = 0;
        for(int i=1;i<=3;++i) T[i][0] = 0;
        T[3][1] = 0;
        T[3][2] = 0;
        T[3][3] = 1;
        T[0][3] = 0;
        T[1][3] = 0;
        T[2][3] = 0;
        
        T[1][1] = cos(r);
        T[1][2] = sin(r);
        T[2][1] = -1*sin(r);
        T[2][2] = cos(r); 
        
        for(int i=0;i<4;++i)
        {
            for(int j=0;j<4;++j)
            {
                cout << T[i][j] << " ";
            }
            cout << endl;
        }
        
        float rr[3][4];
        int n = size;
        cout << "\nSize is : " << n << endl;
        for(int i=0;i<n;i++)
            for(int j=0;j<4;j++)
                rr[i][j]=0;
        
        for(int i=0;i<size;i++)
        {
            for(int j=0;j<4;j++)
            {
                rr[i][j] = 0;
                for(int k=0;k<4;k++)
                    rr[i][j] += nodes[i][k]*T[k][j];
            }
        }        
        cout << endl;
        
        for(int i=0;i<size;++i)    
        {
            for(int j=0;j<4;++j)
                cout << rr[i][j] << " ";
            cout << endl;
        }
        
        for(int i=0;i<size;++i)
        {
            line(round(200 + rr[i%size][0]),round(200 +  rr[i%size][1]), round(200 + rr[(i+1)%size][0]),round(200 +  rr[(i+1)%size][1]));
        }
    }
};

int main()
{
    int gdriver = DETECT, gmode;
    initgraph(&gdriver, &gmode, "");
    matrix m(3);
    m.input();
    m.rotation();
    getch();
    return 0;
}


*****************************************************************************************************************************
PROGRAM 9 : HERMITE /BEIZER CURVE

#include<iostream>
#include<conio.h>
#include<graphics.h>
using namespace std;

int main()
{
    int x[4], y[4];
    double t, xt, yt;
    initwindow(800,800);
    setcolor(YELLOW);
    
    //P1: 50 200, P2: 45 100, P3: 150 100, P4: 200 200
    cout<<"Enter the x and y coordinates of the four control points :- \n";
    for (int i=0; i<4; i++)
    {
    	cout<<"Point "<<i+1<<" : ";
    	cin>>x[i]>>y[i];
	}
	
    for (int i=0; i<3; i++) line(x[i], y[i], x[i+1], y[i+1]);
    
    for (t = 0.0; t < 1.0; t += 0.001)
    {
		xt = (1-t)*(1-t)*(1-t)*x[0] + 3*t*(1-t)*(1-t)*x[1] + 
			3*t*t*(1-t)*x[2] + t*t*t*x[3];
		yt = (1-t)*(1-t)*(1-t)*y[0] + 3*t*(1-t)*(1-t)*y[1] + 
			3*t*t*(1-t)*y[2] + t*t*t*y[3];
		putpixel(xt, yt, RED);
		delay(1);
    }
    getch();
    return 0;
}

